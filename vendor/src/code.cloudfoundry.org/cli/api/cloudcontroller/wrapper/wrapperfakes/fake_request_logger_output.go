// This file was generated by counterfeiter
package wrapperfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/cli/api/cloudcontroller/wrapper"
)

type FakeRequestLoggerOutput struct {
	DisplayBodyStub        func(body []byte) error
	displayBodyMutex       sync.RWMutex
	displayBodyArgsForCall []struct {
		body []byte
	}
	displayBodyReturns struct {
		result1 error
	}
	DisplayHeaderStub        func(name string, value string) error
	displayHeaderMutex       sync.RWMutex
	displayHeaderArgsForCall []struct {
		name  string
		value string
	}
	displayHeaderReturns struct {
		result1 error
	}
	DisplayHostStub        func(name string) error
	displayHostMutex       sync.RWMutex
	displayHostArgsForCall []struct {
		name string
	}
	displayHostReturns struct {
		result1 error
	}
	DisplayRequestHeaderStub        func(method string, uri string, httpProtocol string) error
	displayRequestHeaderMutex       sync.RWMutex
	displayRequestHeaderArgsForCall []struct {
		method       string
		uri          string
		httpProtocol string
	}
	displayRequestHeaderReturns struct {
		result1 error
	}
	DisplayResponseHeaderStub        func(httpProtocol string, status string) error
	displayResponseHeaderMutex       sync.RWMutex
	displayResponseHeaderArgsForCall []struct {
		httpProtocol string
		status       string
	}
	displayResponseHeaderReturns struct {
		result1 error
	}
	DisplayTypeStub        func(name string, requestDate time.Time) error
	displayTypeMutex       sync.RWMutex
	displayTypeArgsForCall []struct {
		name        string
		requestDate time.Time
	}
	displayTypeReturns struct {
		result1 error
	}
	HandleInternalErrorStub        func(err error)
	handleInternalErrorMutex       sync.RWMutex
	handleInternalErrorArgsForCall []struct {
		err error
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct{}
	startReturns     struct {
		result1 error
	}
	StopStub        func() error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct{}
	stopReturns     struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRequestLoggerOutput) DisplayBody(body []byte) error {
	var bodyCopy []byte
	if body != nil {
		bodyCopy = make([]byte, len(body))
		copy(bodyCopy, body)
	}
	fake.displayBodyMutex.Lock()
	fake.displayBodyArgsForCall = append(fake.displayBodyArgsForCall, struct {
		body []byte
	}{bodyCopy})
	fake.recordInvocation("DisplayBody", []interface{}{bodyCopy})
	fake.displayBodyMutex.Unlock()
	if fake.DisplayBodyStub != nil {
		return fake.DisplayBodyStub(body)
	} else {
		return fake.displayBodyReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) DisplayBodyCallCount() int {
	fake.displayBodyMutex.RLock()
	defer fake.displayBodyMutex.RUnlock()
	return len(fake.displayBodyArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayBodyArgsForCall(i int) []byte {
	fake.displayBodyMutex.RLock()
	defer fake.displayBodyMutex.RUnlock()
	return fake.displayBodyArgsForCall[i].body
}

func (fake *FakeRequestLoggerOutput) DisplayBodyReturns(result1 error) {
	fake.DisplayBodyStub = nil
	fake.displayBodyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) DisplayHeader(name string, value string) error {
	fake.displayHeaderMutex.Lock()
	fake.displayHeaderArgsForCall = append(fake.displayHeaderArgsForCall, struct {
		name  string
		value string
	}{name, value})
	fake.recordInvocation("DisplayHeader", []interface{}{name, value})
	fake.displayHeaderMutex.Unlock()
	if fake.DisplayHeaderStub != nil {
		return fake.DisplayHeaderStub(name, value)
	} else {
		return fake.displayHeaderReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) DisplayHeaderCallCount() int {
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	return len(fake.displayHeaderArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayHeaderArgsForCall(i int) (string, string) {
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	return fake.displayHeaderArgsForCall[i].name, fake.displayHeaderArgsForCall[i].value
}

func (fake *FakeRequestLoggerOutput) DisplayHeaderReturns(result1 error) {
	fake.DisplayHeaderStub = nil
	fake.displayHeaderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) DisplayHost(name string) error {
	fake.displayHostMutex.Lock()
	fake.displayHostArgsForCall = append(fake.displayHostArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("DisplayHost", []interface{}{name})
	fake.displayHostMutex.Unlock()
	if fake.DisplayHostStub != nil {
		return fake.DisplayHostStub(name)
	} else {
		return fake.displayHostReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) DisplayHostCallCount() int {
	fake.displayHostMutex.RLock()
	defer fake.displayHostMutex.RUnlock()
	return len(fake.displayHostArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayHostArgsForCall(i int) string {
	fake.displayHostMutex.RLock()
	defer fake.displayHostMutex.RUnlock()
	return fake.displayHostArgsForCall[i].name
}

func (fake *FakeRequestLoggerOutput) DisplayHostReturns(result1 error) {
	fake.DisplayHostStub = nil
	fake.displayHostReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) DisplayRequestHeader(method string, uri string, httpProtocol string) error {
	fake.displayRequestHeaderMutex.Lock()
	fake.displayRequestHeaderArgsForCall = append(fake.displayRequestHeaderArgsForCall, struct {
		method       string
		uri          string
		httpProtocol string
	}{method, uri, httpProtocol})
	fake.recordInvocation("DisplayRequestHeader", []interface{}{method, uri, httpProtocol})
	fake.displayRequestHeaderMutex.Unlock()
	if fake.DisplayRequestHeaderStub != nil {
		return fake.DisplayRequestHeaderStub(method, uri, httpProtocol)
	} else {
		return fake.displayRequestHeaderReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) DisplayRequestHeaderCallCount() int {
	fake.displayRequestHeaderMutex.RLock()
	defer fake.displayRequestHeaderMutex.RUnlock()
	return len(fake.displayRequestHeaderArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayRequestHeaderArgsForCall(i int) (string, string, string) {
	fake.displayRequestHeaderMutex.RLock()
	defer fake.displayRequestHeaderMutex.RUnlock()
	return fake.displayRequestHeaderArgsForCall[i].method, fake.displayRequestHeaderArgsForCall[i].uri, fake.displayRequestHeaderArgsForCall[i].httpProtocol
}

func (fake *FakeRequestLoggerOutput) DisplayRequestHeaderReturns(result1 error) {
	fake.DisplayRequestHeaderStub = nil
	fake.displayRequestHeaderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeader(httpProtocol string, status string) error {
	fake.displayResponseHeaderMutex.Lock()
	fake.displayResponseHeaderArgsForCall = append(fake.displayResponseHeaderArgsForCall, struct {
		httpProtocol string
		status       string
	}{httpProtocol, status})
	fake.recordInvocation("DisplayResponseHeader", []interface{}{httpProtocol, status})
	fake.displayResponseHeaderMutex.Unlock()
	if fake.DisplayResponseHeaderStub != nil {
		return fake.DisplayResponseHeaderStub(httpProtocol, status)
	} else {
		return fake.displayResponseHeaderReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeaderCallCount() int {
	fake.displayResponseHeaderMutex.RLock()
	defer fake.displayResponseHeaderMutex.RUnlock()
	return len(fake.displayResponseHeaderArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeaderArgsForCall(i int) (string, string) {
	fake.displayResponseHeaderMutex.RLock()
	defer fake.displayResponseHeaderMutex.RUnlock()
	return fake.displayResponseHeaderArgsForCall[i].httpProtocol, fake.displayResponseHeaderArgsForCall[i].status
}

func (fake *FakeRequestLoggerOutput) DisplayResponseHeaderReturns(result1 error) {
	fake.DisplayResponseHeaderStub = nil
	fake.displayResponseHeaderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) DisplayType(name string, requestDate time.Time) error {
	fake.displayTypeMutex.Lock()
	fake.displayTypeArgsForCall = append(fake.displayTypeArgsForCall, struct {
		name        string
		requestDate time.Time
	}{name, requestDate})
	fake.recordInvocation("DisplayType", []interface{}{name, requestDate})
	fake.displayTypeMutex.Unlock()
	if fake.DisplayTypeStub != nil {
		return fake.DisplayTypeStub(name, requestDate)
	} else {
		return fake.displayTypeReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) DisplayTypeCallCount() int {
	fake.displayTypeMutex.RLock()
	defer fake.displayTypeMutex.RUnlock()
	return len(fake.displayTypeArgsForCall)
}

func (fake *FakeRequestLoggerOutput) DisplayTypeArgsForCall(i int) (string, time.Time) {
	fake.displayTypeMutex.RLock()
	defer fake.displayTypeMutex.RUnlock()
	return fake.displayTypeArgsForCall[i].name, fake.displayTypeArgsForCall[i].requestDate
}

func (fake *FakeRequestLoggerOutput) DisplayTypeReturns(result1 error) {
	fake.DisplayTypeStub = nil
	fake.displayTypeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) HandleInternalError(err error) {
	fake.handleInternalErrorMutex.Lock()
	fake.handleInternalErrorArgsForCall = append(fake.handleInternalErrorArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("HandleInternalError", []interface{}{err})
	fake.handleInternalErrorMutex.Unlock()
	if fake.HandleInternalErrorStub != nil {
		fake.HandleInternalErrorStub(err)
	}
}

func (fake *FakeRequestLoggerOutput) HandleInternalErrorCallCount() int {
	fake.handleInternalErrorMutex.RLock()
	defer fake.handleInternalErrorMutex.RUnlock()
	return len(fake.handleInternalErrorArgsForCall)
}

func (fake *FakeRequestLoggerOutput) HandleInternalErrorArgsForCall(i int) error {
	fake.handleInternalErrorMutex.RLock()
	defer fake.handleInternalErrorMutex.RUnlock()
	return fake.handleInternalErrorArgsForCall[i].err
}

func (fake *FakeRequestLoggerOutput) Start() error {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	} else {
		return fake.startReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeRequestLoggerOutput) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) Stop() error {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct{}{})
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub()
	} else {
		return fake.stopReturns.result1
	}
}

func (fake *FakeRequestLoggerOutput) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeRequestLoggerOutput) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestLoggerOutput) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.displayBodyMutex.RLock()
	defer fake.displayBodyMutex.RUnlock()
	fake.displayHeaderMutex.RLock()
	defer fake.displayHeaderMutex.RUnlock()
	fake.displayHostMutex.RLock()
	defer fake.displayHostMutex.RUnlock()
	fake.displayRequestHeaderMutex.RLock()
	defer fake.displayRequestHeaderMutex.RUnlock()
	fake.displayResponseHeaderMutex.RLock()
	defer fake.displayResponseHeaderMutex.RUnlock()
	fake.displayTypeMutex.RLock()
	defer fake.displayTypeMutex.RUnlock()
	fake.handleInternalErrorMutex.RLock()
	defer fake.handleInternalErrorMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRequestLoggerOutput) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ wrapper.RequestLoggerOutput = new(FakeRequestLoggerOutput)
