// This file was generated by counterfeiter
package fake_ssh

import (
	"sync"

	"golang.org/x/crypto/ssh"
)

type FakeNewChannel struct {
	AcceptStub        func() (ssh.Channel, <-chan *ssh.Request, error)
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct{}
	acceptReturns     struct {
		result1 ssh.Channel
		result2 <-chan *ssh.Request
		result3 error
	}
	RejectStub        func(reason ssh.RejectionReason, message string) error
	rejectMutex       sync.RWMutex
	rejectArgsForCall []struct {
		reason  ssh.RejectionReason
		message string
	}
	rejectReturns struct {
		result1 error
	}
	ChannelTypeStub        func() string
	channelTypeMutex       sync.RWMutex
	channelTypeArgsForCall []struct{}
	channelTypeReturns     struct {
		result1 string
	}
	ExtraDataStub        func() []byte
	extraDataMutex       sync.RWMutex
	extraDataArgsForCall []struct{}
	extraDataReturns     struct {
		result1 []byte
	}
}

func (fake *FakeNewChannel) Accept() (ssh.Channel, <-chan *ssh.Request, error) {
	fake.acceptMutex.Lock()
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct{}{})
	fake.acceptMutex.Unlock()
	if fake.AcceptStub != nil {
		return fake.AcceptStub()
	} else {
		return fake.acceptReturns.result1, fake.acceptReturns.result2, fake.acceptReturns.result3
	}
}

func (fake *FakeNewChannel) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeNewChannel) AcceptReturns(result1 ssh.Channel, result2 <-chan *ssh.Request, result3 error) {
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 ssh.Channel
		result2 <-chan *ssh.Request
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeNewChannel) Reject(reason ssh.RejectionReason, message string) error {
	fake.rejectMutex.Lock()
	fake.rejectArgsForCall = append(fake.rejectArgsForCall, struct {
		reason  ssh.RejectionReason
		message string
	}{reason, message})
	fake.rejectMutex.Unlock()
	if fake.RejectStub != nil {
		return fake.RejectStub(reason, message)
	} else {
		return fake.rejectReturns.result1
	}
}

func (fake *FakeNewChannel) RejectCallCount() int {
	fake.rejectMutex.RLock()
	defer fake.rejectMutex.RUnlock()
	return len(fake.rejectArgsForCall)
}

func (fake *FakeNewChannel) RejectArgsForCall(i int) (ssh.RejectionReason, string) {
	fake.rejectMutex.RLock()
	defer fake.rejectMutex.RUnlock()
	return fake.rejectArgsForCall[i].reason, fake.rejectArgsForCall[i].message
}

func (fake *FakeNewChannel) RejectReturns(result1 error) {
	fake.RejectStub = nil
	fake.rejectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNewChannel) ChannelType() string {
	fake.channelTypeMutex.Lock()
	fake.channelTypeArgsForCall = append(fake.channelTypeArgsForCall, struct{}{})
	fake.channelTypeMutex.Unlock()
	if fake.ChannelTypeStub != nil {
		return fake.ChannelTypeStub()
	} else {
		return fake.channelTypeReturns.result1
	}
}

func (fake *FakeNewChannel) ChannelTypeCallCount() int {
	fake.channelTypeMutex.RLock()
	defer fake.channelTypeMutex.RUnlock()
	return len(fake.channelTypeArgsForCall)
}

func (fake *FakeNewChannel) ChannelTypeReturns(result1 string) {
	fake.ChannelTypeStub = nil
	fake.channelTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeNewChannel) ExtraData() []byte {
	fake.extraDataMutex.Lock()
	fake.extraDataArgsForCall = append(fake.extraDataArgsForCall, struct{}{})
	fake.extraDataMutex.Unlock()
	if fake.ExtraDataStub != nil {
		return fake.ExtraDataStub()
	} else {
		return fake.extraDataReturns.result1
	}
}

func (fake *FakeNewChannel) ExtraDataCallCount() int {
	fake.extraDataMutex.RLock()
	defer fake.extraDataMutex.RUnlock()
	return len(fake.extraDataArgsForCall)
}

func (fake *FakeNewChannel) ExtraDataReturns(result1 []byte) {
	fake.ExtraDataStub = nil
	fake.extraDataReturns = struct {
		result1 []byte
	}{result1}
}

var _ ssh.NewChannel = new(FakeNewChannel)
